\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{hyperref}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{Assignment 1 Solution}
\author{Rizwan Ahsan, ahsanm7}
\date{\today}

\begin {document}

\maketitle

This report discusses testing of the \verb|ComplexT| and \verb|TriangleT|
classes written for Assignment 1. It also discusses testing of the partner's
version of the two classes. The design restrictions for the assignment
are critiqued and then various related discussion questions are answered.

\section{Assumptions and Exceptions} \label{AssumptAndExcept}
The following assumptions were made:
\begin{itemize}
	\item The arguments provided for the constructor of \verb|ComplexT| class will always be of 
	type float.
	\item The arguments provided for the constructor of \verb|TriangleT| class will always be of type integer and their values will be greater than 0.
\end{itemize}
The following exceptions were handled:
\begin{itemize}
	\item The \verb|recip| method will throw an exception when the value of the denominator variable calculated from the object's real and imaginary numbers is less than or equal 
	to 0 i.e \(x^2 + y^2 <= 0\), x being the real part and y being the imaginary part.
	\item The \verb|div| method will throw a similar exception to \verb|recip| but in this case
	the exception is thrown for the passed in argument's real and imaginary numbers instead.
\end{itemize}


\section{Test Cases and Rationale} \label{Testing}
All of the test cases that were written covers all of the methods in \verb|ComplexT| and 
\verb|TriangleT|. The test cases covers all branches of the code meaning all control flow statements were checked i.e all possible outcomes from if-else were covered. The part of
the code that raised exceptions were also handled specifically. Some methods had edge cases which 
were also handled. Otherwise, the rest of the tests that had no weird input issues were 
handled only once, since that covered all outcomes. On some of the methods that returned
floating value as the output, those cases were tested by rounding the output to 5 decimal places.
By doing so the test will only return passed if the output matches the desired result upto those 5 decimal places, which in turn reduces the floating point error to some degree.


\section{Results of Testing Partner's Code}
My tests file had a total of 26 tests. Running my test cases on my partner's files resulted in 25 passes and 1 failure. The one failed case occured in the \verb|div| method of class \verb|ComplexT|. This failure occured due to the way my test case was implemented. The test will only return true only if the output is equal to the calculated output upto 5 decimal places. But since my test case didn't consider for relative floating point error this returned as failed.


\section{Critique of Given Design Specification}
The given design specification is very good and detailed enough to create the desired outcome. 
However, it didn't mention everything possible cases properly and left it ambigous for the developer to decide. For example, the specification didn't mention the outcome for the possiblity of giving a wrong input to any of the classes. In my opinion, the design would be more robust to say that it will take in only a specific type of input and handle the remaining inputs somehow. Also, for the \verb|tir_type| method, the design specification didn't mention what would be 
returned as the output when the provided input corresponds to more than one type of triangle. So, 
the less the design specification contains ambiguity regarding the functionality the more robust
the design specification will become. This will cause the outcome to be more stable.


\section{Answers to Questions}

\begin{enumerate}[(a)]
	\item There aren't any mutators in \verb|ComplexT| and \verb|TriangleT|.

	The methods which are selectors (getters) are:
		\begin{itemize}
			\item \verb|real|
			\item \verb|imag|
			\item \verb|get_sides|
		\end{itemize}

	\item The two possible state variables for \verb|ComplexT| are:
		\begin{itemize}
			\item Consider the provided input as the real and imaginary part of the complex 
			number.
			\item Consider the provided input and set modulus and argument as the state variables.
		\end{itemize}

		The two possible state variables for \verb|TriangleT| are:
		\begin{itemize}
			\item Set three different variables as the three sides of the triangle.
			\item Setting only variable which consists all three sides in list or tuple.
		\end{itemize}

	\item No, I don't think it would make sense to add methods for greater than and less than because whether a triangle is greater or smaller than another has no use in the real world. On the other hand, figuring out if two triangles are equal can help to prove many mathematical theorems.

	\item Yes, it is possible that the three integer inputs to the constructor for \verb|TriangleT| will not form a geometrically valid triangle. This will happen when the lengths of any of the two sides is not greater than the third side. In this case the contructor should initially check for the validity of the inputs and raise an error if they are invalid. By doing so the user will realise that the inputs they have provided is wrong and fix it immediately rather than finding it out later in more complex calculations.

	\item Yes, having the type of the triangle as a state variable is a good idea. This will immediatly allow the user to figure out what type of triangle it is and use all the properties of that specific triangle in their code. 

	\item The software qualities of performance and usability has an inverse relationship. If the performance of a product is poor then the product becomes difficult to use and vise versa. For example, if the performance of a phone is poor, then it will take a considerable amount of time for it to complete the tasks that it's user would like to do. This will result in the user not wanting to use that product again.

	\item No, I don't think there are any situations where it is not necessary to fake a rational design process. Even if the entire design process is known prior to the starting of designing software there would still be some unknown edge cases that will only come out during the coding phase and testing it out. 

	\item The reusability of code can affect positively towards the reliability of products. For example, it would be unwise to create something from the start if something that works already exists. Like while creating a game, creating all the physics of the game would take a long amount of energy and time but instead using game engines that already has it built-in would save not only a lot of time but increase the chances of creating a well polished game.

	\item The idea of abstraction is that it contains three main properties.
	\begin{itemize}
		\item The concept of hiding or removing. 
		\item The concept of generalization.
		\item The concept of idea versus reality.
	\end{itemize} 
	Some examples of programming languages being abstractions built on top of hardware are:
	\begin{itemize}
		\item The usage of various data types to perform data abstraction.
		\item The creation of abstract data types for example, ComplexT, TriangleT to mimic their properties.
		\item The concept of functions is an abstraction, since the internal mechanism remains hidden to the user. A function is used to generalize a behaviour and it can be reused many times.
	\end{itemize}

\end{enumerate}

\newpage

\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}
%\lstset{language=C,linewidth=.94\textwidth,xleftmargin=1.1cm}

\def\thesection{\Alph{section}}

\section{Code for complex\_adt.py}

\noindent \lstinputlisting{../src/complex_adt.py}

\newpage

\section{Code for triangle\_adt.py}

\noindent \lstinputlisting{../src/triangle_adt.py}

\newpage

\section{Code for test\_driver.py}

\noindent \lstinputlisting{../src/test_driver.py}

\newpage

\section{Code for Partner's complex\_adt.py}

\noindent \lstinputlisting{../partner/complex_adt.py}

\section{Code for Partner's triangle\_adt.py}

\noindent \lstinputlisting{../partner/triangle_adt.py}

\end {document}